import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { randomBytes } from "node:crypto";
import { encodeBase58 } from "../../shared/base58";

interface AgentIdentityFile {
  label: string;
  agentId: string;
  privateJwk: JsonWebKey;
  publicJwk: JsonWebKey;
}

interface CredentialStatus {
  generatedAtIso: string;
  runtimeFiles: {
    localEnvPath: string;
    agentIdentityDir: string;
    credentialNeedsPath: string;
  };
  autoGenerated: {
    SYSTEM_API_KEY: string;
    WORKER_TOKEN: string;
    HELIUS_WEBHOOK_TOKEN: string;
    DEV_TREASURY_KEY_B58: string;
  };
  generatedAgents: Array<{
    label: string;
    agentId: string;
    path: string;
  }>;
  requiredFromUser: Array<{
    key: string;
    reason: string;
    validationCommand: string;
  }>;
}

function randomHex(bytes = 32): string {
  return randomBytes(bytes).toString("hex");
}

async function createAgentIdentity(label: string): Promise<AgentIdentityFile> {
  const pair = await crypto.subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
  const rawPublic = new Uint8Array(await crypto.subtle.exportKey("raw", pair.publicKey));
  const privateJwk = (await crypto.subtle.exportKey("jwk", pair.privateKey)) as JsonWebKey;
  const publicJwk = (await crypto.subtle.exportKey("jwk", pair.publicKey)) as JsonWebKey;
  return {
    label,
    agentId: encodeBase58(rawPublic),
    privateJwk,
    publicJwk
  };
}

function readEnvValue(envPath: string, key: string): string | undefined {
  try {
    const file = readFileSync(envPath, "utf8");
    const line = file
      .split(/\r?\n/)
      .find((entry) => entry.startsWith(`${key}=`) && entry.trim() !== `${key}=`);
    if (!line) {
      return undefined;
    }
    return line.slice(`${key}=`.length).trim();
  } catch {
    return undefined;
  }
}

async function main() {
  const projectRoot = resolve(process.cwd());
  const runtimeDir = resolve(projectRoot, "runtime");
  const identitiesDir = resolve(runtimeDir, "agents");
  mkdirSync(runtimeDir, { recursive: true });
  mkdirSync(identitiesDir, { recursive: true });

  const envPath = resolve(projectRoot, ".env");
  const existingSystemKey = process.env.SYSTEM_API_KEY ?? readEnvValue(envPath, "SYSTEM_API_KEY");
  const existingWorkerToken = process.env.WORKER_TOKEN ?? readEnvValue(envPath, "WORKER_TOKEN");
  const existingWebhookToken =
    process.env.HELIUS_WEBHOOK_TOKEN ?? readEnvValue(envPath, "HELIUS_WEBHOOK_TOKEN");
  const existingTreasuryKey =
    process.env.DEV_TREASURY_KEY_B58 ?? readEnvValue(envPath, "DEV_TREASURY_KEY_B58");

  const generated = {
    SYSTEM_API_KEY: existingSystemKey || `local-${randomHex(20)}`,
    WORKER_TOKEN: existingWorkerToken || `worker-${randomHex(20)}`,
    HELIUS_WEBHOOK_TOKEN: existingWebhookToken || `helius-${randomHex(20)}`,
    DEV_TREASURY_KEY_B58: existingTreasuryKey || encodeBase58(randomBytes(64))
  };

  const identities = await Promise.all([
    createAgentIdentity("smoke_prosecution"),
    createAgentIdentity("smoke_defence"),
    createAgentIdentity("smoke_juror")
  ]);

  const generatedAgents: CredentialStatus["generatedAgents"] = [];
  for (const identity of identities) {
    const path = resolve(identitiesDir, `${identity.label}.json`);
    writeFileSync(path, `${JSON.stringify(identity, null, 2)}\n`, "utf8");
    generatedAgents.push({
      label: identity.label,
      agentId: identity.agentId,
      path
    });
  }

  const localEnvPath = resolve(runtimeDir, "local-secrets.env");
  writeFileSync(
    localEnvPath,
    [
      "# OpenCawt local generated secrets",
      `SYSTEM_API_KEY=${generated.SYSTEM_API_KEY}`,
      `WORKER_TOKEN=${generated.WORKER_TOKEN}`,
      `HELIUS_WEBHOOK_TOKEN=${generated.HELIUS_WEBHOOK_TOKEN}`,
      `DEV_TREASURY_KEY_B58=${generated.DEV_TREASURY_KEY_B58}`,
      "",
      "# Optional helpers for local smoke",
      "SOLANA_MODE=stub",
      "SEAL_WORKER_MODE=stub",
      "DRAND_MODE=stub"
    ].join("\n"),
    "utf8"
  );

  const requiredFromUser: CredentialStatus["requiredFromUser"] = [
    {
      key: "HELIUS_API_KEY",
      reason: "Required for live Helius RPC and DAS calls in rpc mode.",
      validationCommand: "curl -sS \"https://mainnet.helius-rpc.com/?api-key=$HELIUS_API_KEY\""
    },
    {
      key: "HELIUS_RPC_URL",
      reason: "Required for live transaction verification against your Helius tier.",
      validationCommand: "curl -sS \"$HELIUS_RPC_URL\" | head"
    },
    {
      key: "HELIUS_DAS_URL",
      reason: "Required for cNFT asset lookup and indexing resolution.",
      validationCommand:
        "curl -sS \"$HELIUS_DAS_URL\" -H 'content-type: application/json' -d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"searchAssets\",\"params\":{\"limit\":1}}'"
    },
    {
      key: "TREASURY_ADDRESS",
      reason: "Required for production filing fee recipient checks.",
      validationCommand: "echo \"$TREASURY_ADDRESS\""
    },
    {
      key: "BUBBLEGUM_MINT_ENDPOINT",
      reason: "Required for bubblegum_v2 worker mint submission path.",
      validationCommand: "curl -sS \"$BUBBLEGUM_MINT_ENDPOINT\""
    },
    {
      key: "OPENCLAW_GATEWAY_ACCESS",
      reason: "Required to publish and allowlist OpenCawt tools for production agents.",
      validationCommand: "Use your OpenClaw admin console to verify plugin deployment."
    },
    {
      key: "PRODUCTION_CORS_ORIGIN",
      reason: "Required to lock cross-origin access for deployed clients.",
      validationCommand: "echo \"$CORS_ORIGIN\""
    }
  ];

  const credentialNeedsPath = resolve(runtimeDir, "credential-needs.md");
  writeFileSync(
    credentialNeedsPath,
    [
      "# OpenCawt credential handoff",
      "",
      "## Generated locally",
      `- SYSTEM_API_KEY: \`${generated.SYSTEM_API_KEY}\``,
      `- WORKER_TOKEN: \`${generated.WORKER_TOKEN}\``,
      `- HELIUS_WEBHOOK_TOKEN: \`${generated.HELIUS_WEBHOOK_TOKEN}\``,
      `- DEV_TREASURY_KEY_B58: generated in \`${localEnvPath}\``,
      "",
      "## Agent identities generated",
      ...generatedAgents.map((item) => `- ${item.label}: \`${item.agentId}\` (${item.path})`),
      "",
      "## Required from user",
      ...requiredFromUser.map(
        (item) => `- ${item.key}: ${item.reason}\n  Validate: \`${item.validationCommand}\``
      ),
      "",
      "## Next step",
      "Copy the generated values into your local environment for development, then add the required third-party credentials."
    ].join("\n"),
    "utf8"
  );

  const status: CredentialStatus = {
    generatedAtIso: new Date().toISOString(),
    runtimeFiles: {
      localEnvPath,
      agentIdentityDir: identitiesDir,
      credentialNeedsPath
    },
    autoGenerated: generated,
    generatedAgents,
    requiredFromUser
  };

  const statusPath = resolve(runtimeDir, "credential-status.json");
  writeFileSync(statusPath, `${JSON.stringify(status, null, 2)}\n`, "utf8");

  process.stdout.write(`Generated local credentials and handoff files in ${runtimeDir}\n`);
}

main().catch((error) => {
  process.stderr.write(`${String(error)}\n`);
  process.exitCode = 1;
});

